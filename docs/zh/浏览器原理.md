## Chrome开发者工具(性能分析)
Chrome 开发者工具有很多重要的面板，比如与性能相关的有网络面板、Performance 面板、内存面板等，与调试页面相关的有 Elements 面板、Sources 面板、Console 面板等。它一共包含了 10 个功能面板，包括了 Elements、Console、Sources、NetWork、Performance、Memory、Application、Security、Audits 和 Layers。
![devtool](@imgs/devtool.png)


## 渲染总体过程
流水线可分为如下几个子阶段：**构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成**

## Javascript 是如何影响 DOM 树构建的

### DOM 树
从网络传给渲染引擎的HTML文件字节流是无法被渲染引擎理解的，需要转换成渲染引擎可以理解的内部结构，这就是DOM树，DOM树提供了对HTML文档结构化的理解；有三个层面的作用：
* 从视觉的角度看，DOM是生成页面的基础数据结构；
* 从Javascript 角度看，DOM 提供了 javacript脚本操作的接口， 可以访问，修改DOM，从而改变文档结构；
* 从安全的角度看，DOM 是一道安全防护线，一些不安全的内容会在DOM 解析阶段就被举止门外

### DOM 树生成
在渲染引擎内部有一个HTML 解析器（HTML parse）； 将HTML字节流转化成DOM树。   
那么HTML 解析器是在文档全部加载完再解析呢，还是边加载边解析？     
答案是加载多少文档就解析多少DOM树。网络进程和渲染进程会形成数据共享的管道，网络进程接收到数据后就往这个管道里放，而另一端，渲染进程会将接收到的字节流 “喂给” HTML 解析器，
HTML 解析器动态的将HTML字节流解析成 DOM；


### JavaScript 是如何影响 DOM 生成的
##### 情况一：
```  
<html>
<body>
    <div>1</div>
    <script>
    let div1 = document.getElementsByTagName('div')[0]
    div1.innerText = 'time.geekbang'
    </script>
    <div>test</div>
</body>
</html>
```  

解析到 script 标签，渲染引擎判断这是一段脚本，就会暂停 DOM 解析，因为接下来 javascript 有可能会影响当前已经生成 DOM 结构了；javascript 引擎介入，执行script标签中的脚本；
执行完后，HTML 解析器继续解析DOM，直到完成。


##### 情况二：
```
//foo.js
let div1 = document.getElementsByTagName('div')[0]
div1.innerText = 'time.geekbang'
```

```
<html>
<body>
    <div>1</div>
    <script type="text/javascript" src='foo.js'></script>
    <div>test</div>
</body>
</html>
``` 
如上面这种，内嵌脚本改成外部引入脚本，DOM解析暂停，不过需要注意的是这里有个下载文件的过程，下载会阻塞DOM解析；网络，文件大小等都会影响下载过程；
不过Chrome 浏览器做了很多优化，其中一个主要的优化是预解析操作，渲染引擎收到字节流之后，会开启一个预解析线程，用来分析HTML中的JS文件，CSS文件等，如果有，预解析线程提前下载文件。

###### 优化办法：
1. CDN 来加速javascript 文件的加载
2. 压缩文件体积
3. 如果文件没有 DOM 操作，就可以将javascript 文件设置为一步加载， 通过 async 或 defer 来标记代码

``` 
 <script async type="text/javascript" src='foo.js'></script>

<script defer type="text/javascript" src='foo.js'></script>
``` 


##### async 和 defer 的区别：
虽然都是异步的，async标志的脚本一旦加载完就执行，defer标记的脚本，需要在 DOMContentLoaded 事件之前执行， async会阻塞DOM解析，defer不会阻塞




## CSS如何影响首次加载时的白屏时间？

### 最简单的
```
//theme.css
div{ 
    color : coral;
    background-color:black
}
```

```
<html>
<head>
    <link href="theme.css" rel="stylesheet">
</head>
<body>
    <div>geekbang com</div>
</body>
</html>
```

![template](@imgs/DX-20220601@2x.png)


### 稍微复杂一点的
```
//theme.css
div{ 
    color : coral;
    background-color:black
}
```

```
<html>
<head>
    <link href="theme.css" rel="stylesheet">
</head>
<body>
    <div>geekbang com</div>
    <script>
        console.log('time.geekbang.org')
    </script>
    <div>geekbang com</div>
</body>
</html>
```
![template](@imgs/css-fuza.png)

### 再复杂一点的
```
//theme.css
div{ 
    color : coral;
    background-color:black
}
```

``` 
//foo.js
console.log('time.geekbang.org')
``` 

```
<html>
<head>
    <link href="theme.css" rel="stylesheet">
</head>
<body>
    <div>geekbang com</div>
    <script src='foo.js'></script>
    <div>geekbang com</div>
</body>
</html>
```
![template](@imgs/fuza2.png)


##### 通常情况下的瓶颈主要体现在下载 CSS 文件、下载 JavaScript 文件和执行 JavaScript。
* 通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。
* 但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。
* 还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 async 或者 defer。
* 对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。

## 为什么CSS 动画比 Javascript 高效
每个显示器都有固定的刷新频率，通常是 60HZ，也就是每秒更新 60 张图片；DOM树生成之后，我们还经历布局、分层、绘制、合成、显示等阶段后才能显示出漂亮的页面。

##### 任何一桢的生成方式有，重排、重绘和合成三种
这三种方式的渲染路径是不同的，通常渲染路径越长，生成图像花费的时间就越多。比如重排，它需要重新根据 CSSOM 和 DOM 来计算布局树，这样生成一幅图片时，会让整个渲染流水线的每个阶段都执行一遍，如果布局复杂的话，就很难保证渲染的效率了。而重绘因为没有了重新布局的阶段，操作效率稍微高点，但是依然需要重新计算绘制信息，并触发绘制操作之后的一系列操作。

相较于重排和重绘合成操作的路径就显得非常短了，并不需要触发布局和绘制两个阶段，如果采用了 GPU，那么合成的效率会非常高。推荐合成方式优先

##### Chrome 中的合成技术，可以用三个词来概括总结：分层、分块和合成。
在 Chrome 的渲染流水线中，分层体现在生成布局树之后,渲染引擎会根据布局树的特点将其转换为层树（Layer Tree），层树是渲染流水线后续流程的基础结构。   

绘制阶段其实并不是真正地绘出图片，而是将绘制指令组合成一个列表，比如一个图层要设置的背景为黑色，并且还要在中间画一个圆形，那么绘制过程会生成|Paint BackGroundColor:Black | Paint Circle|这样的绘制指令列表，绘制过程就完成了。

有了绘制列表之后，就需要进入光栅化阶段了，光栅化就是按照绘制列表中的指令生成图片。每一个图层都对应一张图片，合成线程有了这些图片之后，会将这些图片合成为“一张”图片，并最终将生成的图片发送到后缓冲区。这就是一个大致的分层、合成流程。

需要重点关注的是，合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。

Chrome 又采取了一个策略：在首次合成图块的时候使用一个低分辨率的图片

### 如何利用分层技术优化代码
如果使用 JavaScript 来写这些效果，会牵涉到整个渲染流水线，所以 JavaScript 的绘制效率会非常低下。

这时你可以使用 will-change 来告诉渲染引擎你会对该元素做一些特效变换，CSS 代码如下：
```
.box {
will-change: transform, opacity;
}
```

这段代码就是提前告诉渲染引擎 box 元素将要做几何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现一层，等这些变换发生时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率。这也是 CSS 动画比 JavaScript 动画高效的原因。

#### 注意：
不是所有的CSS动画都高效， 记能直接在合成线程中完成的任务都 **不会  改变图层的内容**，如文字信息的改变，布局的改变，颜色的改变，统统不会涉及，涉及到这些内容的变化就要牵涉到重排或者重绘了。

能直接在合成线程中实现的是整个图层的几何变换，透明度变换，阴影等，这些变换都不会影响到图层的内容。

<!--  -->
## 如何系统的优化页面
就是让页面更快地显示和响应。
##### 通常一个页面有三个阶段：加载阶段、交互阶段和关闭阶段。
* 加载阶段，是指从发出请求到渲染出完整页面的过程，影响到这个阶段的主要因素有网络和 JavaScript 脚本。
* 交互阶段，主要是从页面加载完成到用户交互的整合过程，影响到这个阶段的主要因素是 JavaScript 脚本。
* 关闭阶段，主要是用户发出关闭指令后页面所做的一些清理操作。

### 典型的加载阶段渲染流水线:
![template](@imgs/classic.png)

并非所有的资源都会阻塞页面的首次绘制，比如图片、音频、视频等文件就不会阻塞页面的首次渲染；而 JavaScript、首次请求的 HTML 资源文件、CSS 文件是会阻塞首次渲染的，因为在构建 DOM 的过程中需要 HTML 和 JavaScript 文件，在构造渲染树的过程中需要用到 CSS 文件。

### 影响页面首次渲染的核心因素
我们把这些能阻塞网页首次渲染的资源称为**关键资源**。基于关键资源，我们可以继续细化出来三个影响页面首次渲染的核心因素。

1. **第一个是关键资源个数**。
2. **第二个是关键资源大小**.
3. **第三个是请求关键资源需要多少个 RTT（Round Trip Time）**

> **RTT:**
> 当使用 TCP 协议传输一个文件时，比如这个文件大小是 0.1M，由于 TCP 的特性，这个数据并不是一次传输到服务端的，而是需要拆分成一个个数据包来回多次进行传输的。RTT 就是这里的往返时延。它是网络中一个重要的性能指> 标，表示从发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延。通常 1 个 HTTP 的数据包在 14KB 左右，所以 1 个 0.1M 的页面就需要拆分成 8 个包来传输了，也就是说需要 8 个 RTT。


由于渲染引擎有一个预解析的线程，在接收到 HTML 数据之后，预解析线程会快速扫描 HTML 数据中的关键资源，一旦扫描到了，会立马发起请求，你可以认为 JavaScript 和 CSS 是同时发起请求的，所以它们的请求是重叠的，那么计算它们的 RTT 时，只需要计算体积最大的那个数据就可以了。

从上面的三个影响页面渲染方面，总结解决方法。

### 如何减少关键资源的个数？
1. 一种方式是可以将 JavaScript 和 CSS 改成内联的形式。
2. 如果 JavaScript 代码没有 DOM 或者 CSSOM 的操作，则可以改成 async 或者 defer 属性,变成非关键资源。
3. 对于 CSS，如果不是在构建页面之前加载的，则可以添加媒体取消阻止显现的标志,变成非关键资源。
> 给 link 标签添加 media=“none” onload=“this.media=‘all’”

### 如何减少关键资源的大小？
1. 可以压缩 CSS 和 JavaScript 资源。
2. 移除 HTML、CSS、JavaScript 文件中一些注释内容。
3. 前面讲的取消 CSS 或者 JavaScript 中关键资源的方式。

### 如何减少关键资源 RTT 的次数？
1. 减少关键资源的个数和减少关键资源的大小搭配来实现。
2. 使用 CDN 来减少每次 RTT 时长。


### 交互阶段优化
谈交互阶段的优化，其实就是在谈渲染进程渲染帧的速度，因为在交互阶段，帧的渲染速度决定了交互的流畅度。因此讨论页面优化实际上就是讨论渲染引擎是如何渲染帧的，否则就无法优化帧率。

我们先来看看交互阶段的渲染流水线（如下图）。和加载阶段的渲染流水线有一些不同的地方是，在交互阶段没有了加载关键资源和构建 DOM、CSSOM 流程，通常是由 JavaScript 触发交互动画的。
![交互阶段](@imgs/interact.png)

结合上图，我们来一起回顾下交互阶段是如何生成一个帧的。大部分情况下，生成一个新的帧都是由 JavaScript 通过修改 DOM 或者 CSSOM 来触发的。还有另外一部分帧是由 CSS 来触发的。

**优化：一个大的原则就是让单个帧的生成速度变快**
1. 减少 JavaScript 脚本执行时间，有时 JavaScript 函数的一次执行时间可能有几百毫秒，这就严重霸占了主线程执行其他渲染任务的时间。
> 一种是将一次执行的函数分解为多个任务，使得每次的执行时间不要过久。

> 另一种是采用 Web Workers。你可以把 Web Workers 当作主线程之外的一个线程，在 Web Workers 中是可以执行 JavaScript 脚本的，不过 Web Workers 中没有 DOM、CSSOM 环境，这意味着在 Web Workers 中是> 无法通过 JavaScript 来访问 DOM 的，所以我们可以把一些和 DOM 操作无关且耗时的任务放到 Web Workers 中去执行。

2. 避免强制同步布局      
在介绍强制同步布局之前，我们先来聊聊正常情况下的布局操作。通过 DOM 接口执行添加元素或者删除元素等操作后，是需要重新计算样式和布局的，不过正常情况下这些操作都是在另外的任务中异步完成的，这样做是为了避免当前的任务占用太长的主线程时间。

**所谓强制同步布局，是指 JavaScript 强制将计算样式和布局操作提前到当前的任务中。**       
为了避免强制同步布局，我们可以调整策略，在修改 DOM 之前查询相关值

3. 避免布局抖动
还有一种比强制同步布局更坏的情况，那就是布局抖动。所谓布局抖动，是指在一次 JavaScript 执行过程中，多次执行强制布局和抖动操作。为了直观理解，你可以看下面的代码：
```

function foo() {
    let time_li = document.getElementById("time_li")
    for (let i = 0; i < 100; i++) {
        let main_div = document.getElementById("mian_div")
        let new_node = document.createElement("li")
        let textnode = document.createTextNode("time.geekbang")
        new_node.appendChild(textnode);
        new_node.offsetHeight = time_li.offsetHeight;
        document.getElementById("mian_div").appendChild(new_node);
    }
}
```

4. 合理利用 CSS 合成动画
合成动画是直接在合成线程上执行的，这和在主线程上执行的布局、绘制等操作不同，如果主线程被 JavaScript 或者一些布局任务占用，CSS 动画依然能继续执行。所以要尽量利用好 CSS 合成动画，如果能让 CSS 处理动画，就尽量交给 CSS 来操作。

另外，如果能提前知道对某个元素执行动画操作，那就最好将其标记为 will-change，这是告诉渲染引擎需要将该元素单独生成一个图层。

5. 避免频繁的垃圾回收
我们知道 JavaScript 使用了自动垃圾回收机制，如果在一些函数中频繁创建临时对象，那么垃圾回收器也会频繁地去执行垃圾回收策略。这样当垃圾回收操作发生时，就会占用主线程，从而影响到其他任务的执行，严重的话还会让用户产生掉帧、不流畅的感觉。

## 虚拟DOM和实际的DOM有何不同？

### DOM 缺陷
我们可以调用document.body.appendChild(node)往 body 节点上添加一个元素，调用该 API 之后会引发一系列的连锁反应。首先渲染引擎会将 node 节点添加到 body 节点之上，然后触发**样式计算、布局、绘制、栅格化、合成等任务，我们把这一过程称为重排。** 除了重排之外，还有可能引起重绘或者合成操作，形象地理解就是“牵一发而动全身”。另外，对于 DOM 的不当操作还有可能引发强制同步布局和布局抖动的问题，这些操作都会大大降低渲染效率。因此，对于 DOM 的操作我们时刻都需要非常小心谨慎。

对于一些复杂的页面或者目前使用非常多的单页应用来说，其 DOM 结构是非常复杂的，而且还需要不断地去修改 DOM 树，每次操作 DOM 渲染引擎都需要进行重排、重绘或者合成等操作，因为 DOM 结构复杂，所生成的页面结构也会很复杂，对于这些复杂的页面，执行一次重排或者重绘操作都是非常耗时的，这就给我们带来了真正的性能问题。

所以我们需要有一种方式来减少 JavaScript 对 DOM 的操作，这时候虚拟 DOM 就上场了。

### 什么是虚拟 DOM
##### 虚拟 DOM 到底要解决哪些事情
* 将页面改变的内容应用到虚拟 DOM 上，而不是直接应用到 DOM 上。
* 变化被应用到虚拟 DOM 上时，虚拟 DOM 并不急着去渲染页面，而仅仅是调整虚拟 DOM 的内部状态，这样操作虚拟 DOM 的代价就变得非常轻了。
* 在虚拟 DOM 收集到足够的改变时，再把这些变化一次性应用到真实的 DOM 上。

### 双缓存
在开发游戏或者处理其他图像的过程中，屏幕从前缓冲区读取数据然后显示。但是很多图形操作都很复杂且需要大量的运算，比如一幅完整的画面，可能需要计算多次才能完成，如果每次计算完一部分图像，就将其写入缓冲区，那么就会造成一个后果，那就是在显示一个稍微复杂点的图像的过程中，你看到的页面效果可能是一部分一部分地显示出来，因此在刷新页面的过程中，会让用户感受到界面的闪烁。

而使用双缓存，可以让你先将计算的中间结果存放在另一个缓冲区中，等全部的计算结束，该缓冲区已经存储了完整的图形之后，再将该缓冲区的图形数据一次性复制到显示缓冲区，这样就使得整个图像的输出非常稳定。

在这里，你可以把虚拟 DOM 看成是 DOM 的一个 buffer，和图形显示一样，它会在完成一次完整的操作之后，再把结果应用到 DOM 上，这样就能减少一些不必要的更新，同时还能保证 DOM 的稳定输出。

### MVC 模式
在各大设计模式当中，MVC 是一个非常重要且应用广泛的模式，因为它能将数据和视图进行分离，在涉及到一些复杂的项目时，能够大大减轻项目的耦合度，使得程序易于维护。

MVC 的基础结构：
![MVC](@imgs/mvc.png)
