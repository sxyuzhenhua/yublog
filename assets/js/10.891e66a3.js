(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{205:function(e,t,a){"use strict";a.r(t);var r=a(0),n=Object(r.a)({},(function(){var e=this.$createElement;this._self._c;return this._m(0)}),[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[a("h2",{attrs:{id:"vue3-0-性能提升"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue3-0-性能提升"}},[e._v("#")]),e._v(" VUE3.0 性能提升")]),e._v(" "),a("h3",{attrs:{id:"编译阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#编译阶段"}},[e._v("#")]),e._v(" 编译阶段")]),e._v(" "),a("ul",[a("li",[a("ol",[a("li",[e._v("diff算法优化\n标记静态节点，diff的时候直接跳过")])])]),e._v(" "),a("li",[a("ol",{attrs:{start:"2"}},[a("li",[e._v("静态提升\n不参与更新的元素会提升，只会创建一次，渲染的时候直接用")])])]),e._v(" "),a("li",[a("ol",{attrs:{start:"3"}},[a("li",[e._v("事件监听缓存\n默认情况事件行为会被视为动态节点，开启缓存之后会标记为静态，下次直接用")])])]),e._v(" "),a("li",[a("ol",{attrs:{start:"4"}},[a("li",[e._v("SSR优化\n当静态内容大到一定量级时候，会用createStaticVNode方法在客户端去生成一个static node，这些静态node，会被直接innerHtml，就不需要创建对象，然后根据对象渲染")])])])]),e._v(" "),a("h3",{attrs:{id:"源码体积"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#源码体积"}},[e._v("#")]),e._v(" 源码体积")]),e._v(" "),a("p",[e._v("移除不常用的API，tree shanking")]),e._v(" "),a("p",[e._v("任何一个函数，如ref、reavtived、computed等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小")]),e._v(" "),a("h3",{attrs:{id:"响应式系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#响应式系统"}},[e._v("#")]),e._v(" 响应式系统")]),e._v(" "),a("p",[e._v("vue2中采用 defineProperty来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加getter和setter，实现响应式")]),e._v(" "),a("p",[e._v("vue3采用proxy重写了响应式系统，因为proxy可以对整个对象进行监听，所以不需要深度遍历")]),e._v(" "),a("ul",[a("li",[e._v("可以监听动态属性的添加")]),e._v(" "),a("li",[e._v("可以监听到数组的索引和数组length属性")]),e._v(" "),a("li",[e._v("可以监听删除属性")])]),e._v(" "),a("h2",{attrs:{id:"为什么用proxy-替代-defineproperty"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么用proxy-替代-defineproperty"}},[e._v("#")]),e._v(" 为什么用proxy  替代 defineProperty")]),e._v(" "),a("h3",{attrs:{id:"defineproperty"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#defineproperty"}},[e._v("#")]),e._v(" DefineProperty")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function defineReactive(data, key, value) {\n    observe(value) // 如果 嵌套对象， 还需要递归\n\t Object.defineProperty(data, key, {\n\t\t enumerable: true,\n\t\t configurable: true,\n\t\t get: function defineGet() {\n\t\t\t console.log(`get key: ${key} value: ${value}`)\n\t\t\t return value\n\t\t },\n\t\t set: function defineSet(newVal) {\n            observe(newVal) // 新增是对象的话\n\t\t\t console.log(`set key: ${key} value: ${newVal}`)\n\t\t\t value = newVal\n\t\t }\n\t })\n}\n \n // 如果对象有多个 key, 需要遍历\nfunction observe(data) {\n    if(data === null) return;\n    if(typeof data === 'object') {\n        Object.keys(data).forEach(function(key) {\n            defineReactive(data, key, data[key])\n        })\n    }\n}\n \nlet arr = [1, 2, 3]\nlet o = {name: 'zhang', age: 20, family: { father: 'baba', mother: 'mama'}}\nobserve(o)\n")])])]),a("h5",{attrs:{id:"缺点："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缺点："}},[e._v("#")]),e._v(" 缺点：")]),e._v(" "),a("ul",[a("li",[e._v("对象进行删除与添加属性操作，无法劫持到")]),e._v(" "),a("li",[e._v("数组进行监听不管用，例如方法：push, pop不可以； arrDate[0] = 99 是可以的")])]),e._v(" "),a("p",[e._v("所以vue2 加了 delete, set, 对数组的方法进行劫持；\n如果嵌套很深，需要在开始渲染的时候就递归，很浪费，并且数据太深的话会卡")]),e._v(" "),a("h3",{attrs:{id:"proxy"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#proxy"}},[e._v("#")]),e._v(" Proxy")]),e._v(" "),a("p",[e._v("Proxy 的监听是针对对象而言的，这个对象的所有操作会进入监听操作")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function reactive(obj) {\n    if (typeof obj !== 'object' && obj != null) {\n        return obj\n    }\n    // Proxy相当于在对象外层加拦截\n    const observed = new Proxy(obj, {\n        get(target, key, receiver) {\n            const res = Reflect.get(target, key, receiver)\n            console.log(`获取${key}:${res}`)\n            return res\n        },\n        set(target, key, value, receiver) {\n            const res = Reflect.set(target, key, value, receiver)\n            console.log(`设置${key}:${value}`)\n            return res\n        },\n        deleteProperty(target, key) {\n            const res = Reflect.deleteProperty(target, key)\n            console.log(`删除${key}:${res}`)\n            return isObject(res) ? reactive(res) : res;  // \n        }\n    })\n    return observed\n}\nlet arr = [1, 2, 3]\nlet o1 = {name: 'zhang', age: 20, family: { father: 'baba', mother: 'mama'}}\n\nlet o = reactive(o1)\n")])])]),a("h2",{attrs:{id:"composition-api-与-optional-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#composition-api-与-optional-api"}},[e._v("#")]),e._v(" Composition API 与 optional API")]),e._v(" "),a("ul",[a("li",[e._v("在逻辑组织与逻辑复用， Composition API 是优于 optional API；")]),e._v(" "),a("li",[e._v("因为 Composition API 几乎是函数，会有更好的类型推断；")]),e._v(" "),a("li",[e._v("Composition API 对 tree Shaking 更友好， 代码更容易压缩；")]),e._v(" "),a("li",[e._v("Composition API 见不到 this 的使用，减少 this 指向不明确")]),e._v(" "),a("li",[e._v("如果是小型组件，也是可以继续用 optional API")])]),e._v(" "),a("p",[e._v("https://vue3js.cn/interview/vue3/performance.html#%E4%B8%80%E3%80%81%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5")]),e._v(" "),a("p",[e._v("vue 整体流程")])])}],!1,null,null,null);t.default=n.exports}}]);