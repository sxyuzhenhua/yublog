<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>VUE3.0 性能提升 | 渲染器</title>
    <meta name="description" content="也许是讲渲染器相关内容中最细最全的了吧">
    
    
    <link rel="preload" href="/yublog/assets/css/0.styles.2be786d9.css" as="style"><link rel="preload" href="/yublog/assets/js/app.37e56814.js" as="script"><link rel="preload" href="/yublog/assets/js/10.891e66a3.js" as="script"><link rel="prefetch" href="/yublog/assets/js/11.9ccbd59b.js"><link rel="prefetch" href="/yublog/assets/js/12.73e8c7ba.js"><link rel="prefetch" href="/yublog/assets/js/13.a48112d4.js"><link rel="prefetch" href="/yublog/assets/js/14.4169265d.js"><link rel="prefetch" href="/yublog/assets/js/15.3071b19d.js"><link rel="prefetch" href="/yublog/assets/js/16.f9d88530.js"><link rel="prefetch" href="/yublog/assets/js/17.c1ab2bac.js"><link rel="prefetch" href="/yublog/assets/js/18.bb240c5d.js"><link rel="prefetch" href="/yublog/assets/js/19.4491ed2b.js"><link rel="prefetch" href="/yublog/assets/js/2.530ddd4d.js"><link rel="prefetch" href="/yublog/assets/js/3.a7947606.js"><link rel="prefetch" href="/yublog/assets/js/4.518986e4.js"><link rel="prefetch" href="/yublog/assets/js/5.62c60af0.js"><link rel="prefetch" href="/yublog/assets/js/6.88e275c6.js"><link rel="prefetch" href="/yublog/assets/js/7.112b3033.js"><link rel="prefetch" href="/yublog/assets/js/8.d1d6dc10.js"><link rel="prefetch" href="/yublog/assets/js/9.20ad09d8.js">
    <link rel="stylesheet" href="/yublog/assets/css/0.styles.2be786d9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/yublog/zh/" class="home-link router-link-active"><!----> <span class="site-name">渲染器</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Languages</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/yublog/" class="nav-link">English</a></li><li class="dropdown-item"><!----> <a href="/yublog/zh/Vue3.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">简体中文</a></li></ul></div></div> <a href="https://github.com/sxyuzhenhua/yublog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Languages</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/yublog/" class="nav-link">English</a></li><li class="dropdown-item"><!----> <a href="/yublog/zh/Vue3.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">简体中文</a></li></ul></div></div> <a href="https://github.com/sxyuzhenhua/yublog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><a href="/yublog/zh/Vue的CSS的Scoped原理.html" class="sidebar-link">Vue的CSS的Scoped原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/Vue的CSS的Scoped原理.html#vue的css的scoped原理" class="sidebar-link">Vue的CSS的Scoped原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/Vue的CSS的Scoped原理.html#缺点" class="sidebar-link">缺点</a></li></ul></li></ul></li><li><a href="/yublog/zh/设计模式.html" class="sidebar-link">设计模式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/设计模式.html#typescript在线编辑" class="sidebar-link">typescript在线编辑</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/设计模式.html#面向对象" class="sidebar-link">面向对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/设计模式.html#继承" class="sidebar-link">继承</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/设计模式.html#封装" class="sidebar-link">封装</a></li></ul></li></ul></li><li><a href="/yublog/zh/webpack.html" class="sidebar-link">webpack</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/webpack.html#一、介绍" class="sidebar-link">一、介绍</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/webpack.html#二、环境差异" class="sidebar-link">二、环境差异</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/webpack.html#三、publicpath-区别" class="sidebar-link">三、publicPath 区别</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/webpack.html#四、babel-loader-babel-core-预设-的关系" class="sidebar-link">四、babel-loader &amp; @babel/core &amp; 预设 的关系</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/webpack.html#五、sourcemap" class="sidebar-link">五、SourceMap</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/webpack.html#六、-mpa多页面配置" class="sidebar-link">六、 MPA多页面配置</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/webpack.html#七、引入第三方类库-lodash，jquery）" class="sidebar-link">七、引入第三方类库(lodash，jquery）</a></li></ul></li><li><a href="/yublog/zh/浏览器原理.html" class="sidebar-link">浏览器原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#chrome架构" class="sidebar-link">Chrome架构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#先区分进程和线程" class="sidebar-link">先区分进程和线程</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#进程与线程的关系" class="sidebar-link">进程与线程的关系</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#单进程浏览器时代" class="sidebar-link">单进程浏览器时代</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#多进程浏览器时代" class="sidebar-link">多进程浏览器时代</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#目前多进程架构" class="sidebar-link">目前多进程架构</a></li></ul></li><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#http请求流程：为什么很多站点第二次打开速度会很快？" class="sidebar-link">HTTP请求流程：为什么很多站点第二次打开速度会很快？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#浏览器端发起-http-请求流程" class="sidebar-link">浏览器端发起 HTTP 请求流程</a></li></ul></li><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#chrome开发者工具-性能分析" class="sidebar-link">Chrome开发者工具(性能分析)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#网络面板" class="sidebar-link">网络面板</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#优化时间线上耗时项" class="sidebar-link">优化时间线上耗时项</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#渲染总体过程" class="sidebar-link">渲染总体过程</a></li></ul></li><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#javascript-是如何影响-dom-树构建的" class="sidebar-link">Javascript 是如何影响 DOM 树构建的</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#dom-树" class="sidebar-link">DOM 树</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#dom-树生成" class="sidebar-link">DOM 树生成</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#javascript-是如何影响-dom-生成的" class="sidebar-link">JavaScript 是如何影响 DOM 生成的</a></li></ul></li><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#css如何影响首次加载时的白屏时间？" class="sidebar-link">CSS如何影响首次加载时的白屏时间？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#最简单的" class="sidebar-link">最简单的</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#稍微复杂一点的" class="sidebar-link">稍微复杂一点的</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#再复杂一点的" class="sidebar-link">再复杂一点的</a></li></ul></li><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#为什么css-动画比-javascript-高效" class="sidebar-link">为什么CSS 动画比 Javascript 高效</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#如何利用分层技术优化代码" class="sidebar-link">如何利用分层技术优化代码</a></li></ul></li><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#如何系统的优化页面" class="sidebar-link">如何系统的优化页面</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#典型的加载阶段渲染流水线" class="sidebar-link">典型的加载阶段渲染流水线:</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#影响页面首次渲染的核心因素" class="sidebar-link">影响页面首次渲染的核心因素</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#如何减少关键资源的个数？" class="sidebar-link">如何减少关键资源的个数？</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#如何减少关键资源的大小？" class="sidebar-link">如何减少关键资源的大小？</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#如何减少关键资源-rtt-的次数？" class="sidebar-link">如何减少关键资源 RTT 的次数？</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#交互阶段优化" class="sidebar-link">交互阶段优化</a></li></ul></li><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#虚拟dom和实际的dom有何不同？" class="sidebar-link">虚拟DOM和实际的DOM有何不同？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#dom-缺陷" class="sidebar-link">DOM 缺陷</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#什么是虚拟-dom" class="sidebar-link">什么是虚拟 DOM</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#双缓存" class="sidebar-link">双缓存</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#mvc-模式" class="sidebar-link">MVC 模式</a></li></ul></li><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#渐进式网页应用（pwa）" class="sidebar-link">渐进式网页应用（PWA）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#什么是-pwa？pwa-又是以什么方式切入到移动端的呢？" class="sidebar-link">什么是 PWA？PWA 又是以什么方式切入到移动端的呢？</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#web-应用-vs-本地应用" class="sidebar-link">Web 应用 VS 本地应用</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#什么是-service-worker" class="sidebar-link">什么是 Service Worker</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#service-worker-的设计思路" class="sidebar-link">Service Worker 的设计思路</a></li></ul></li><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#webcomponent-搭积木构建web应用" class="sidebar-link">WebComponent(搭积木构建Web应用)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#什么是组件化呢？" class="sidebar-link">什么是组件化呢？</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#阻碍前端组件化的因素" class="sidebar-link">阻碍前端组件化的因素</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#webcomponent-组件化开发" class="sidebar-link">WebComponent 组件化开发</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/浏览器原理.html#浏览器如何实现影子-dom" class="sidebar-link">浏览器如何实现影子 DOM</a></li></ul></li></ul></li><li><a href="/yublog/zh/抓包工具.html" class="sidebar-link">抓包工具</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/抓包工具.html#whistle" class="sidebar-link">whistle</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/抓包工具.html#wireshark" class="sidebar-link">Wireshark</a></li></ul></li><li><a href="/yublog/zh/面试.html" class="sidebar-link">面试</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/面试.html#关于循环-await-异步面试题" class="sidebar-link">关于循环 + await 异步面试题</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/面试.html#对两个版本号进行大小比较" class="sidebar-link">对两个版本号进行大小比较</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/面试.html#实现多维对象的扁平化处理" class="sidebar-link">实现多维对象的扁平化处理</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/面试.html#实现对“url问号传参”的解析" class="sidebar-link">实现对“URL问号传参”的解析</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/面试.html#阿拉伯数字转为中文数字" class="sidebar-link">阿拉伯数字转为中文数字</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/面试.html#将一维数组转换成树形结构" class="sidebar-link">将一维数组转换成树形结构</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/面试.html#在多维数据结构中，按条件实现深层查找" class="sidebar-link">在多维数据结构中，按条件实现深层查找</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/面试.html#基于js实现-均匀运动-的动画" class="sidebar-link">基于JS实现 &quot;均匀运动&quot; 的动画</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/面试.html#关于规避请求失败，递归获取需要数据的问题" class="sidebar-link">关于规避请求失败，递归获取需要数据的问题</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/面试.html#仿抖音发布视频时的-“-话题解析”-逻辑" class="sidebar-link">仿抖音发布视频时的 “#话题解析” 逻辑</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/面试.html#词法环境，变量环境，outer-作用域链-和-this" class="sidebar-link">(词法环境，变量环境，outer)[作用域链]   和 this</a></li></ul></li><li><a href="/yublog/zh/React.html" class="sidebar-link">React</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#生命周期" class="sidebar-link">生命周期</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#使用第三方库-d3" class="sidebar-link">使用第三方库, d3</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#hooks" class="sidebar-link">Hooks</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#usestate：让函数组件具有维持状态的能力" class="sidebar-link">useState：让函数组件具有维持状态的能力</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#useeffect：执行副作用" class="sidebar-link">useEffect：执行副作用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#useeffect-还有两个特殊的用法：-没有依赖项，以及依赖项作为空数组。" class="sidebar-link">useEffect 还有两个特殊的用法： 没有依赖项，以及依赖项作为空数组。</a></li></ul></li><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#理解-hooks-的依赖" class="sidebar-link">理解 Hooks 的依赖</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#掌握-hooks-的使用规则" class="sidebar-link">掌握 Hooks 的使用规则</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#为什么要避免重复定义回调函数？" class="sidebar-link">为什么要避免重复定义回调函数？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#usecallback：缓存回调函数" class="sidebar-link">useCallback：缓存回调函数</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#usememo：缓存计算的结果" class="sidebar-link">useMemo：缓存计算的结果</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#useref：在多次渲染之间共享数据" class="sidebar-link">useRef：在多次渲染之间共享数据</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#usecontext：定义全局状态" class="sidebar-link">useContext：定义全局状态</a></li></ul></li><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#如何正确理解函数组件的生命周期？" class="sidebar-link">如何正确理解函数组件的生命周期？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#重新思考组件的生命周期" class="sidebar-link">重新思考组件的生命周期</a></li></ul></li><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#自定义hooks-：四个典型的使用场景" class="sidebar-link">自定义Hooks ：四个典型的使用场景</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#如何创建自定义-hooks？" class="sidebar-link">如何创建自定义 Hooks？</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#封装通用逻辑：useasync" class="sidebar-link">封装通用逻辑：useAsync</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#监听浏览器状态：usescroll" class="sidebar-link">监听浏览器状态：useScroll</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#拆分复杂组件" class="sidebar-link">拆分复杂组件</a></li></ul></li><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#全局状态管理：如何在函数组件中使用-redux？" class="sidebar-link">全局状态管理：如何在函数组件中使用 Redux？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#理解-redux-的三个基本概念" class="sidebar-link">理解 Redux 的三个基本概念</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#如何在-react-中使用-redux" class="sidebar-link">如何在 React 中使用 Redux</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#使用-redux-处理异步逻辑" class="sidebar-link">使用 Redux 处理异步逻辑</a></li></ul></li><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#复杂状态处理：如何保证状态一致性？" class="sidebar-link">复杂状态处理：如何保证状态一致性？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#实战演练：创建自定义受控组件" class="sidebar-link">实战演练：创建自定义受控组件</a></li></ul></li><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#异步处理：如何向服务器端发送请求？" class="sidebar-link">异步处理：如何向服务器端发送请求？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#实现自己的-api-client" class="sidebar-link">实现自己的 API Client</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#多个-api-调用：如何处理并发或串行请求？" class="sidebar-link">多个 API 调用：如何处理并发或串行请求？</a></li></ul></li><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#函数组件设计模式：如何应对复杂条件渲染场景？" class="sidebar-link">函数组件设计模式：如何应对复杂条件渲染场景？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#容器模式：实现按条件执行-hooks" class="sidebar-link">容器模式：实现按条件执行 Hooks</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#使用-render-props-模式重用-ui-逻辑" class="sidebar-link">使用 render props 模式重用 UI 逻辑</a></li></ul></li><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#事件处理：如何创建自定义事件？" class="sidebar-link">事件处理：如何创建自定义事件？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#react-原生事件的原理：合成事件（synthetic-events）" class="sidebar-link">React 原生事件的原理：合成事件（Synthetic Events）</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#创建自定义事件" class="sidebar-link">创建自定义事件</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#使用-hooks-封装键盘事件开" class="sidebar-link">使用 Hooks 封装键盘事件开</a></li></ul></li><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#form：hooks-给-form-处理带来了哪些新变化？" class="sidebar-link">Form：Hooks 给 Form 处理带来了哪些新变化？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#在表单中使用-react-组件：受控组件和非受控组件" class="sidebar-link">在表单中使用 React 组件：受控组件和非受控组件</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/React.html#使用-hooks-简化表单处理" class="sidebar-link">使用 Hooks 简化表单处理</a></li></ul></li></ul></li><li><a href="/yublog/zh/Redux.html" class="sidebar-link">Redux</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/Redux.html#一、不可变数据" class="sidebar-link">一、不可变数据</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/Redux.html#二、为啥需要不可变数据" class="sidebar-link">二、为啥需要不可变数据</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/Redux.html#三、如何操作不可变数据" class="sidebar-link">三、如何操作不可变数据</a></li></ul></li><li><a href="/yublog/zh/react-router.html" class="sidebar-link">react-router</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/react-router.html#react-router-api" class="sidebar-link">React Router API</a></li></ul></li><li><a href="/yublog/zh/npm发布.html" class="sidebar-link">npm发布</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/npm发布.html#package-json-版本区别（～-lastest）" class="sidebar-link">package.json  版本区别（～ ^ lastest）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/npm发布.html#查看" class="sidebar-link">查看</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/npm发布.html#查看具体的dist-tag-包括prerelease与稳定版本" class="sidebar-link">查看具体的dist-tag (包括prerelease与稳定版本)</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/npm发布.html#发布一个带tag的版本" class="sidebar-link">发布一个带tag的版本</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/npm发布.html#切换版本" class="sidebar-link">切换版本</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/npm发布.html#用户默认安装的版本就是latest" class="sidebar-link">用户默认安装的版本就是latest</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/npm发布.html#如何安装tag版本" class="sidebar-link">如何安装tag版本</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/npm发布.html#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/npm发布.html#发布测试包，不影响线上安装latest" class="sidebar-link">发布测试包，不影响线上安装latest</a></li></ul></li></ul></li><li><a href="/yublog/zh/杂.html" class="sidebar-link">杂</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/杂.html#主要记录平时工作中遇到的一些点" class="sidebar-link">主要记录平时工作中遇到的一些点</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/杂.html#window-addeventlistener-pushstate-handler-不管用" class="sidebar-link">window.addEventListener('pushstate', handler) 不管用</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/杂.html#低代码：" class="sidebar-link">低代码：</a></li></ul></li></ul></li><li><a href="/yublog/zh/如何在项目中落地TS.html" class="sidebar-link">如何在项目中落地TS</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/yublog/zh/Vue3.html" aria-current="page" class="active sidebar-link">Vue3</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/Vue3.html#vue3-0-性能提升" class="sidebar-link">VUE3.0 性能提升</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/Vue3.html#编译阶段" class="sidebar-link">编译阶段</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/Vue3.html#源码体积" class="sidebar-link">源码体积</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/Vue3.html#响应式系统" class="sidebar-link">响应式系统</a></li></ul></li><li class="sidebar-sub-header"><a href="/yublog/zh/Vue3.html#为什么用proxy-替代-defineproperty" class="sidebar-link">为什么用proxy  替代 defineProperty</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/yublog/zh/Vue3.html#defineproperty" class="sidebar-link">DefineProperty</a></li><li class="sidebar-sub-header"><a href="/yublog/zh/Vue3.html#proxy" class="sidebar-link">Proxy</a></li></ul></li><li class="sidebar-sub-header"><a href="/yublog/zh/Vue3.html#composition-api-与-optional-api" class="sidebar-link">Composition API 与 optional API</a></li></ul></li></ul> </div> <div class="page"> <div class="content"><h2 id="vue3-0-性能提升"><a href="#vue3-0-性能提升" class="header-anchor">#</a> VUE3.0 性能提升</h2> <h3 id="编译阶段"><a href="#编译阶段" class="header-anchor">#</a> 编译阶段</h3> <ul><li><ol><li>diff算法优化
标记静态节点，diff的时候直接跳过</li></ol></li> <li><ol start="2"><li>静态提升
不参与更新的元素会提升，只会创建一次，渲染的时候直接用</li></ol></li> <li><ol start="3"><li>事件监听缓存
默认情况事件行为会被视为动态节点，开启缓存之后会标记为静态，下次直接用</li></ol></li> <li><ol start="4"><li>SSR优化
当静态内容大到一定量级时候，会用createStaticVNode方法在客户端去生成一个static node，这些静态node，会被直接innerHtml，就不需要创建对象，然后根据对象渲染</li></ol></li></ul> <h3 id="源码体积"><a href="#源码体积" class="header-anchor">#</a> 源码体积</h3> <p>移除不常用的API，tree shanking</p> <p>任何一个函数，如ref、reavtived、computed等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小</p> <h3 id="响应式系统"><a href="#响应式系统" class="header-anchor">#</a> 响应式系统</h3> <p>vue2中采用 defineProperty来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加getter和setter，实现响应式</p> <p>vue3采用proxy重写了响应式系统，因为proxy可以对整个对象进行监听，所以不需要深度遍历</p> <ul><li>可以监听动态属性的添加</li> <li>可以监听到数组的索引和数组length属性</li> <li>可以监听删除属性</li></ul> <h2 id="为什么用proxy-替代-defineproperty"><a href="#为什么用proxy-替代-defineproperty" class="header-anchor">#</a> 为什么用proxy  替代 defineProperty</h2> <h3 id="defineproperty"><a href="#defineproperty" class="header-anchor">#</a> DefineProperty</h3> <div class="language- extra-class"><pre class="language-text"><code>function defineReactive(data, key, value) {
    observe(value) // 如果 嵌套对象， 还需要递归
	 Object.defineProperty(data, key, {
		 enumerable: true,
		 configurable: true,
		 get: function defineGet() {
			 console.log(`get key: ${key} value: ${value}`)
			 return value
		 },
		 set: function defineSet(newVal) {
            observe(newVal) // 新增是对象的话
			 console.log(`set key: ${key} value: ${newVal}`)
			 value = newVal
		 }
	 })
}
 
 // 如果对象有多个 key, 需要遍历
function observe(data) {
    if(data === null) return;
    if(typeof data === 'object') {
        Object.keys(data).forEach(function(key) {
            defineReactive(data, key, data[key])
        })
    }
}
 
let arr = [1, 2, 3]
let o = {name: 'zhang', age: 20, family: { father: 'baba', mother: 'mama'}}
observe(o)
</code></pre></div><h5 id="缺点："><a href="#缺点：" class="header-anchor">#</a> 缺点：</h5> <ul><li>对象进行删除与添加属性操作，无法劫持到</li> <li>数组进行监听不管用，例如方法：push, pop不可以； arrDate[0] = 99 是可以的</li></ul> <p>所以vue2 加了 delete, set, 对数组的方法进行劫持；
如果嵌套很深，需要在开始渲染的时候就递归，很浪费，并且数据太深的话会卡</p> <h3 id="proxy"><a href="#proxy" class="header-anchor">#</a> Proxy</h3> <p>Proxy 的监听是针对对象而言的，这个对象的所有操作会进入监听操作</p> <div class="language- extra-class"><pre class="language-text"><code>function reactive(obj) {
    if (typeof obj !== 'object' &amp;&amp; obj != null) {
        return obj
    }
    // Proxy相当于在对象外层加拦截
    const observed = new Proxy(obj, {
        get(target, key, receiver) {
            const res = Reflect.get(target, key, receiver)
            console.log(`获取${key}:${res}`)
            return res
        },
        set(target, key, value, receiver) {
            const res = Reflect.set(target, key, value, receiver)
            console.log(`设置${key}:${value}`)
            return res
        },
        deleteProperty(target, key) {
            const res = Reflect.deleteProperty(target, key)
            console.log(`删除${key}:${res}`)
            return isObject(res) ? reactive(res) : res;  // 
        }
    })
    return observed
}
let arr = [1, 2, 3]
let o1 = {name: 'zhang', age: 20, family: { father: 'baba', mother: 'mama'}}

let o = reactive(o1)
</code></pre></div><h2 id="composition-api-与-optional-api"><a href="#composition-api-与-optional-api" class="header-anchor">#</a> Composition API 与 optional API</h2> <ul><li>在逻辑组织与逻辑复用， Composition API 是优于 optional API；</li> <li>因为 Composition API 几乎是函数，会有更好的类型推断；</li> <li>Composition API 对 tree Shaking 更友好， 代码更容易压缩；</li> <li>Composition API 见不到 this 的使用，减少 this 指向不明确</li> <li>如果是小型组件，也是可以继续用 optional API</li></ul> <p>https://vue3js.cn/interview/vue3/performance.html#%E4%B8%80%E3%80%81%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5</p> <p>vue 整体流程</p></div> <div class="page-edit"><div class="edit-link"><a href="https://github.com/sxyuzhenhua/yublog/edit/master/docs/zh/Vue3.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/yublog/zh/如何在项目中落地TS.html" class="prev">
          如何在项目中落地TS
        </a></span> <!----></p></div> </div> <!----></div></div>
    <script src="/yublog/assets/js/app.37e56814.js" defer></script><script src="/yublog/assets/js/10.891e66a3.js" defer></script>
  </body>
</html>
